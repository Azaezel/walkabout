<!DOCTYPE html>

<html>
<head>
	<title>Installation Guide | Walkabout</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
	<img src="images/walkabout.png" class="banner" />
	<p class="title">INSTALLATION GUIDE</p>

	<ol class="toc">
		<li><a href="#introduction">Introduction</a></li>
		<li><a href="#structure">Directory structure</a></li>
		<li><a href="#easy">Easy install (new project)</a></li>
		<li><a href="#winmerge">Installing with WinMerge (existing project)</a></li>
		<li><a href="#custom">Custom install (existing project)</a></li>
		<li><a href="#UAISK">UAISK integration</a></li>
	</ol>

	<h1 id="introduction">Introduction</h1>
	<p>This guide will walk you through the process of installing <strong>Walkabout</strong> into Torque 3D.
	<strong>Walkabout</strong> is a complex product and requires significant additions (and a few modifications) to the engine code.
	If you follow this guide, you should be fine, but if you need more detailed information on the modifications <strong>Walkabout</strong> makes, see the Engine Modifications file.</p>

	<p>If you’re installing <strong>Walkabout</strong> into a new project that you haven’t started to modify already, you’re in luck: your install should be very simple.
	Follow the guide in the <a href="#easy">Easy install</a> section below.</p>

	<p>If you’ve made source code or script changes already, however, you have two options.
	The difficult option is to follow the instructions in the <a href="#custom">Custom install</a> section.
	The easy option is to install a program like <a href="#winmerge">WinMerge</a>, which will let you visually merge the differences between your code and <strong>Walkabout</strong>’s code.</p>

	<p class="important"><strong>IMPORTANT!</strong>
	It is highly recommended that you do not perform a full manual install.
	The instructions are included for completeness, but starting from a fresh project or using WinMerge are much easier!</p>

	<h1 id="structure">Directory structure</h1>
	<p>In the instructions below, I want to make as few assumptions as I can about where you’ve installed Torque and how your projects are laid out.
	With that in mind, here are some abbreviations I will use:</p>

	<table>
		<tr><th>Abbreviation</th> <th>Explanation</th> <th>Example</th></tr>
		<tr><td>install directory</td> <td>The location you installed Torque 3D.</td> <td class="path">C:\Torque\Torque 3D 1.1 Final</td></tr>
		<tr><td>engine directory</td> <td>The location of Torque’s engine source files.</td> <td class="path">C:\Torque\Torque 3D 1.1 Final\Engine\source</td></tr>
		<tr><td>project directory</td> <td>The location of the project you’d like to install <strong>Walkabout</strong> to.</td> <td class="path">C:\Torque\Torque 3D 1.1 Final\My Projects\SuperFunGame</td></tr>
		<tr><td>game directory</td> <td>The location of your project’s game folder.</td> <td class="path">C:\Torque\Torque 3D 1.1 Final\My Projects\SuperFunGame\game</td></tr>
		<tr><td>Walkabout</td> <td>The folder that contains your <strong>Walkabout</strong> download.</td> <td class="path">C:\Users\Me\Downloads\Walkabout R1\Torque 3D 1.1 Final</td></tr>
	</table>

	<h1 id="easy">Easy install (new project)</h1>
	<p>If you’re working with a new T3D install (blank project based on Full or Empty template),
	then you will be able to simply copy over all the files in your <strong>Walkabout</strong> download and overwrite the existing ones.
	To install <strong>Walkabout</strong> in a new T3D project, do the following:</p>
	<ol>
		<li>Copy <span class="path">Walkabout/Engine/source</span> to <span class="path">engine directory</span> and select ‘Copy and Replace’ for all items when prompted.</li>
		<li>Copy <span class="path">Walkabout/game</span> to <span class="path">game directory</span> and select ‘Copy and Replace’ for all items when prompted.</li>
		<li>Copy <span class="path">Walkabout/Tools/projectGenerator/modules/walkabout.inc</span> to <span class="path">install directory/Tools/projectGenerator/modules</span>
		<li>In <span class="path">project directory/buildFiles/config</span>, open <span class="path">projectCode.conf</span> with a regular text editor
		(Notepad, Notepad++, and WordPad should be fine. Do not use Microsoft Word, OpenOffice, or other word processors!).<br />
		After these lines:<br />
		<pre>
   // Here is an example of how to include your project specific code 
   // In this case all the code in the "custom" folder in your project's source directory would be added
   // addSrcDir('../source/custom');
		</pre>
		Add this: <br />
		<pre>   includeModule( 'walkabout' );</pre></li>
		<li>In <span class="path">project directory</span>, double-click on <span class="path">generateProjects.bat</span>.</li>
		<li>Recompile the engine.</li>
	</ol>

	<h1 id="winmerge">Installing with WinMerge (existing project)</h1>
	<p>If you have already made script and source code changes to Torque 3D in your own project,
	you’ll need to be a bit more careful when you integrate <strong>Walkabout</strong>, to avoid its changes overwriting your own changes!</p>

	<p>Once you’ve installed <a href="http://www.winmerge.org">WinMerge</a> or the merging tool of your choice, follow the steps below.
	Note that instructions will assume you are using WinMerge - if your merge tool has differences, you’ll need to work them out yourself!</p>

	<p>First, compare <span class="path">Walkabout/source</span> to <span class="path">engine directory</span>.
	If there is a file with differences, double-click it to view and edit them.</p>

	<img src="images/winmerge-dir.png" />
	<p class="caption">Viewing differences in the T3D directory.</p>

	<p>Once inside a file, press Alt+Down to quickly scroll to the next difference,
	and Alt+Right to copy from the left-hand-side (<strong>Walkabout</strong> file) to the right-hand-side (your engine file).</p>

	<img src="images/winmerge-file.png" />
	<p class="caption">Editing conflicts inside a file.</p>

	<p>Next, compare <span class="path">Walkabout/game</span> to <span class="path">game directory</span>. Copy over files that don’t exist in your tree, and edit any conflicts within existing files.</p>

	<p>Finally, follow steps 3-6 from <a href="#easy">Easy install</a>.
	Note that step 5 will rewrite your Visual Studio project files, so if you’ve modified them, you will need to redo those modifications.</p>

	<h1 id="custom">Custom install (existing project)</h1>

	<p class="title">1. COPY NEW FILES</p>

	<ol>
		<li>Copy <span class="path">Walkabout/source/walkabout</span> to <span class="path">engine directory</span></li>
		<li>Copy all files in <span class="path">Walkabout/source/collision</span> to <span class="path">engine directory/collision</span></li>
		<li>Copy all files in <span class="path">Walkabout/source/gui</span> to <span class="path">engine directory/gui</span></li>
		<li>Copy <span class="path">Walkabout/game/tools</span> to <span class="path">game directory</span></li>
		<li>Optionally, copy all files in <span class="path">Walkabout/game/scripts/server to <span class="path">game directory/scripts/server</span></li>
	</ol>

	<p class="title">2. SOURCE CODE MODIFICATIONS</p>

	<p>In <span class="path">engine directory/scene/sceneContainer.h</span>, after:</p>

<pre>
   /// A hint that the polyist is used for
   /// selection from an editor or other tool.
   PLC_Selection,
</pre>

	<p>Add:</p>

<pre>
   /// A hint that the polylist is used for
   /// building a representation of the environment
   /// used for navigation.
   PLC_Navigation,
</pre>

	<p>In <span class="path">engine directory/T3D/convexShape.cpp</span>, after:</p>

<pre>
   // Add Surfaces...

  const Vector< ConvexShape::Face > faceList = mGeometry.faces;
</pre>

	<p>Add:</p>

<pre>
   if(context == PLC_Navigation)
   {
	  for(S32 i = 0; i < faceList.size(); i++)
	  {
		 const ConvexShape::Face &face = faceList[i];                

		 S32 s = face.triangles.size();
		 for(S32 j = 0; j < s; j++)
		 {
			plist->begin(0, s*i + j);

			plist->plane(PlaneF(face.centroid, face.normal));

			plist->vertex(base + face.points[face.triangles[j].p0]);
			plist->vertex(base + face.points[face.triangles[j].p1]);
			plist->vertex(base + face.points[face.triangles[j].p2]);

			plist->end();
		 }      
	  }
	  return true;
   }
</pre>


	<p>In <span class="path">engine directory/T3D/groundPlane.cpp</span>, replace this method:</p>
<pre>
bool GroundPlane::buildPolyList( PolyListContext context, AbstractPolyList* polyList, const Box3F&, const SphereF& )
{
   ...
}
</pre>

	<p>With:</p>

<pre>
bool GroundPlane::buildPolyList( PolyListContext context, AbstractPolyList* polyList, const Box3F& box, const SphereF& )
{
   polyList->setObject( this );
   polyList->setTransform( &MatrixF::Identity, Point3F( 1.0f, 1.0f, 1.0f ) );

   if(context == PLC_Navigation)
   {
	  F32 z = getPosition().z;
	  Point3F
		 p0(box.minExtents.x, box.maxExtents.y, z),
		 p1(box.maxExtents.x, box.maxExtents.y, z),
		 p2(box.maxExtents.x, box.minExtents.y, z),
		 p3(box.minExtents.x, box.minExtents.y, z);

	  // Add vertices to poly list.
	  U32 v0 = polyList->addPoint(p0);
	  polyList->addPoint(p1);
	  polyList->addPoint(p2);
	  polyList->addPoint(p3);

	  // Add plane between first three vertices.
	  polyList->begin(0, 0);
	  polyList->vertex(v0);
	  polyList->vertex(v0+1);
	  polyList->vertex(v0+2);
	  polyList->plane(v0, v0+1, v0+2);
	  polyList->end();

	  // Add plane between last three vertices.
	  polyList->begin(0, 1);
	  polyList->vertex(v0+2);
	  polyList->vertex(v0+3);
	  polyList->vertex(v0);
	  polyList->plane(v0+2, v0+3, v0);
	  polyList->end();

	  return true;
   }

   Box3F planeBox = getPlaneBox();
   polyList->addBox( planeBox, mMaterial );

   return true;
}
</pre>

	<p>In <span class="path">engine directory/terrain/terrCollision.cpp</span>, replace this line:</p>

<pre>
bool TerrainBlock::buildPolyList(PolyListContext, AbstractPolyList* polyList, const Box3F &box, const SphereF&)
</pre>

	<p>With:</p>

<pre>
bool TerrainBlock::buildPolyList(PolyListContext context, AbstractPolyList* polyList, const Box3F &box, const SphereF&)
</pre>

	<p>Replace this block:</p>

<pre>
  //
  for (S32 x = xStart; x < xEnd; x++) 
  {
	 S32 xi = x & BlockMask;
	 const TerrainSquare *sq = mFile->findSquare( 0, xi, yi );
</pre>

	<p>With:</p>

<pre>
	  F32 wy1 = y * mSquareSize, wy2 = (y + 1) * mSquareSize;
	  if(((wy1 > osBox.maxExtents.y && wy2 > osBox.maxExtents.y) ||
		  (wy1 < osBox.minExtents.y && wy2 < osBox.minExtents.y)) &&
		   context == PLC_Navigation)
		 continue;

	  //
	  for (S32 x = xStart; x < xEnd; x++) 
	  {
		 S32 xi = x & BlockMask;
		 const TerrainSquare *sq = mFile->findSquare( 0, xi, yi );

		 F32 wx1 = x * mSquareSize, wx2 = (x + 1) * mSquareSize;
		 if(((wx1 > osBox.maxExtents.x && wx2 > osBox.maxExtents.x) ||
			 (wx1 < osBox.minExtents.x && wx2 < osBox.minExtents.x)) &&
			  context == PLC_Navigation)
			continue;
</pre>

	<p>In <span class="path">engine directory/T3D/aiPlayer.h</span>, after:</p>

<pre>
#ifndef _PLAYER_H_
#include "T3D/player.h"
#endif
</pre>

	<p>Add:</p>

<pre>
#include "walkabout/navPath.h"
#include "walkabout/navMesh.h"
#include "walkabout/coverPoint.h"
</pre>

	<p>After:</p>

<pre>
   // Utility Methods
   void throwCallback( const char *name );
</pre>

	<p>Add:</p>

<pre>
   /// Should we jump?
   enum JumpStates {
      None,  ///< No, don't jump.
      Now,   ///< Jump immediately.
      Ledge, ///< Jump when we walk off a ledge.
   } mJump;

   /// Stores information about a path.
   struct PathData {
      /// Pointer to path object.
      SimObjectPtr<Nav::NavPath> path;
      /// Do we own our path? If so, we will delete it when finished.
      bool owned;
      /// Path node we're at.
      U32 index;
      /// Default constructor.
      PathData() : path(NULL)
      {
         owned = false;
         index = 0;
      }
   };

   /// Path we are currently following.
   PathData mPathData;

   /// Clear out the current path.
   void clearPath();

   /// Get the current path we're following.
   Nav::NavPath *getPath() { return mPathData.path; }

   /// Stores information about our cover.
   struct CoverData {
      /// Pointer to a cover point.
      SimObjectPtr<CoverPoint> cover;
      /// Default constructor.
      CoverData() : cover(NULL)
      {
      }
   };

   /// Current cover we're trying to get to.
   CoverData mCoverData;

   /// Stop searching for cover.
   void clearCover();

   /// Get cover we are moving to.
   CoverPoint *getCover() { return mCoverData.cover; }

   /// Information about a target we're following.
   struct FollowData {
      /// Object to follow.
      SimObjectPtr<SceneObject> object;
      /// Distance at whcih to follow.
      F32 radius;
      /// Default constructor.
      FollowData() : object(NULL)
      {
         radius = 5.0f;
      }
   };

   /// Current object we're following.
   FollowData mFollowData;

   /// Stop following me!
   void clearFollow();

   /// NavMesh we pathfind on.
   SimObjectPtr<Nav::NavMesh> mNavMesh;

   /// Move to the specified node in the current path.
   void moveToNode(S32 node);

protected:
   virtual void onReachDestination();
   virtual void onStuck();
</pre>

	<p>After:</p>

<pre>
   bool onAdd();
</pre>

	<p>Add:</p>

<pre>
   void onRemove();
</pre>

	<p>After:</p>

<pre>
   void stopMove();
</pre>

	<p>Add:</p>

<pre>
   /// @name Pathfinding
   /// @{

   enum NavSize {
      Small,
      Regular,
      Large
   } mNavSize;
   void setNavSize(NavSize size) { mNavSize = size; updateNavMesh(); }
   NavSize getNavSize() const { return mNavSize; }

   bool setPathDestination(const Point3F &pos);
   Point3F getPathDestination() const;

   void followNavPath(Nav::NavPath *path);
   void followObject(SceneObject *obj, F32 radius);

   void repath();

   bool findCover(const Point3F &from, F32 radius);

   Nav::NavMesh *findNavMesh() const;
   void updateNavMesh();
   Nav::NavMesh *getNavMesh() const { return mNavMesh; }

   /// Types of link we can use.
   Nav::LinkData mLinkTypes;

   /// @}
</pre>

	<p>In <span class="path">engine directory.T3D/aiPlayer.cpp</span>, after:</p>

<pre>
   mAimOffset = Point3F(0.0f, 0.0f, 0.0f);
</pre>

	<p>Add:</p>

<pre>
   mJump = None;
   mNavSize = Regular;
   mLinkTypes = Nav::LinkData(Nav::AllFlags);
</pre>

	<p>After:</p>

<pre>
   endGroup( "AI" );
</pre>

	<p>Add:</p>

<pre>
   addGroup("Pathfinding");

   addField("allowWalk", TypeBool, Offset(mLinkTypes.walk, AIPlayer),
      "Allow the character to walk on dry land.");
   addField("allowJump", TypeBool, Offset(mLinkTypes.jump, AIPlayer),
      "Allow the character to use jump links.");
   addField("allowDrop", TypeBool, Offset(mLinkTypes.drop, AIPlayer),
      "Allow the character to use drop links.");
   addField("allowSwim", TypeBool, Offset(mLinkTypes.swim, AIPlayer),
      "Allow the character tomove in water.");
   addField("allowLedge", TypeBool, Offset(mLinkTypes.ledge, AIPlayer),
      "Allow the character to jump ledges.");
   addField("allowClimb", TypeBool, Offset(mLinkTypes.climb, AIPlayer),
      "Allow the character to use climb links.");
   addField("allowTeleport", TypeBool, Offset(mLinkTypes.teleport, AIPlayer),
      "Allow the character to use teleporters.");

   endGroup("Pathfinding");
</pre>

	<p>After:</p>

<pre>
bool AIPlayer::onAdd()
{
   ...
}
</pre>

	<p>Add:</p>

<pre>
void AIPlayer::onRemove() 
{
   clearPath();
   clearCover();
   clearFollow();
   Parent::onRemove();
}
</pre>

	<p>After:</p>

<pre>
void AIPlayer::stopMove()
{
   mMoveState = ModeStop;
</pre>

	<p>Add:</p>

<pre>
   clearPath();
   clearCover();
   clearFollow();
</pre>

	<p>After:</p>

<pre>
   Point3F location = eye.getPosition();
   Point3F rotation = getRotation();
</pre>

	<p>Add:</p>

<pre>
   if(mDamageState == Enabled)
   {
      if(mMoveState != ModeStop)
         updateNavMesh();
      if(!mFollowData.object.isNull())
      {
         if(mPathData.path.isNull())
         {
            if((getPosition() - mFollowData.object->getPosition()).len() > mFollowData.radius)
               followObject(mFollowData.object, mFollowData.radius);
         }
         else
         {
            if((mPathData.path->mTo - mFollowData.object->getPosition()).len() > mFollowData.radius)
               repath();
            else if((getPosition() - mFollowData.object->getPosition()).len() < mFollowData.radius)
            {
               clearPath();
               mMoveState = ModeStop;
            }
         }
      }
   }
</pre>

	<p>Replace this:</p>

<pre>
		 mMoveState = ModeStop;
		 throwCallback("onReachDestination");
</pre>

	<p>With:</p>

<pre>
		 mMoveState = ModeStop;
		 onReachDestination();
</pre>

	<p>Replace this:</p>

<pre>
			   mMoveState = ModeStuck;
			   throwCallback("onMoveStuck");
</pre>

	<p>With:</p>

<pre>
			   mMoveState = ModeStuck;
			   onStuck();
</pre>

	<p>After:</p>

<pre>
   for( int i = 0; i < MaxTriggerKeys; i++ )
	  movePtr->trigger[i] = getImageTriggerState(i);
</pre>

	<p>Add:</p>

<pre>
   if(mJump == Now)
   {
      movePtr->trigger[2] = true;
      mJump = None;
   }
   else if(mJump == Ledge)
   {
      // If we're not touching the ground, jump!
      RayInfo info;
      if(!getContainer()->castRay(getPosition(), getPosition() - Point3F(0, 0, 0.4f), StaticShapeObjectType, &info))
      {
         movePtr->trigger[2] = true;
         mJump = None;
      }
   }
</pre>

	<p>After:</p>

<pre>
void AIPlayer::throwCallback( const char *name )
{
   Con::executef(getDataBlock(), name, getIdString());
}
</pre>

	<p>Add:</p>

<pre>
/**
 * Called when we get within mMoveTolerance of our destination set using
 * setMoveDestination(). Only fires the script callback if we are at the end
 * of a pathfinding path, or have no pathfinding path.
 */
void AIPlayer::onReachDestination()
{
   if(!mPathData.path.isNull())
   {
      if(mPathData.index == mPathData.path->size() - 1)
      {
         // Handle looping paths.
         if(mPathData.path->mIsLooping)
            moveToNode(0);
         // Otherwise end path.
         else
         {
            clearPath();
            throwCallback("onReachDestination");
         }
      }
      else
      {
         moveToNode(mPathData.index + 1);
         // Throw callback every time if we're on a looping path.
         //if(mPathData.path->mIsLooping)
            //throwCallback("onReachDestination");
      }
   }
   else
      throwCallback("onReachDestination");
}

/**
 * Called when we move less than mMoveStuckTolerance in a tick, signalling
 * that some obstacle is preventing us from getting where we need to go.
 */
void AIPlayer::onStuck()
{
   if(!mPathData.path.isNull())
      repath();
   else
      throwCallback("onMoveStuck");
}

// --------------------------------------------------------------------------------------------
// Pathfinding
// --------------------------------------------------------------------------------------------

void AIPlayer::clearPath()
{
   // Only delete if we own the path.
   if(!mPathData.path.isNull() && mPathData.owned)
      mPathData.path->deleteObject();
   // Reset path data.
   mPathData = PathData();
}

void AIPlayer::clearCover()
{
   // Notify cover that we are no longer on our way.
   if(!mCoverData.cover.isNull())
      mCoverData.cover->setOccupied(false);
   mCoverData = CoverData();
}

void AIPlayer::clearFollow()
{
   mFollowData = FollowData();
}

void AIPlayer::moveToNode(S32 node)
{
   if(mPathData.path.isNull())
      return;

   // -1 is shorthand for 'last path node'.
   if(node == -1)
      node = mPathData.path->size() - 1;

   // Consider slowing down on the last path node.
   setMoveDestination(mPathData.path->getNode(node), false);

   // Check flags for this segment.
   if(mPathData.index)
   {
      U16 flags = mPathData.path->getFlags(node - 1);
      // Jump if we must.
      if(flags & Nav::LedgeFlag)
         mJump = Ledge;
      else if(flags & Nav::JumpFlag)
         mJump = Now;
      else
         // Catch pathing errors.
         mJump = None;
   }

   // Store current index.
   mPathData.index = node;
}

bool AIPlayer::setPathDestination(const Point3F &pos)
{
   // Pathfinding only happens on the server.
   if(!isServerObject())
      return false;

   if(!getNavMesh())
      updateNavMesh();
   // If we can't find a mesh, just move regularly.
   if(!getNavMesh())
   {
      //setMoveDestination(pos);
      return false;
   }

   // Create a new path.
   Nav::NavPath *path = new Nav::NavPath();
   if(path)
   {
      path->mMesh = getNavMesh();
      path->mFrom = getPosition();
      path->mTo = pos;
      path->mFromSet = path->mToSet = true;
      path->mAlwaysRender = true;
      path->mLinkTypes = mLinkTypes;
      // Paths plan automatically upon being registered.
      if(!path->registerObject())
      {
         delete path;
         return false;
      }
   }
   else
      return false;

   if(path->success())
   {
      // Clear any current path we might have.
      clearPath();
      clearCover();
      clearFollow();
      // Store new path.
      mPathData.path = path;
      mPathData.owned = true;
      // Skip node 0, which we are currently standing on.
      moveToNode(1);
      return true;
   }
   else
   {
      // Just move normally if we can't path.
      //setMoveDestination(pos, true);
      //return;
      //throwCallback("onPathFailed");
      path->deleteObject();
      return false;
   }
}

DefineEngineMethod(AIPlayer, setPathDestination, bool, (Point3F goal),,
   "@brief Tells the AI to find a path to the location provided\n\n"

   "@param goal Coordinates in world space representing location to move to.\n"
   "@return True if a path was found.\n\n"

   "@see getPathDestination()\n"
   "@see setMoveDestination()\n")
{
   return object->setPathDestination(goal);
}

Point3F AIPlayer::getPathDestination() const
{
   if(!mPathData.path.isNull())
      return mPathData.path->mTo;
   return Point3F(0, 0, 0);
}

DefineEngineMethod(AIPlayer, getPathDestination, Point3F, (),,
   "@brief Get the AIPlayer's current pathfinding destination.\n\n"

   "@return Returns a point containing the \"x y z\" position "
   "of the AIPlayer's current path destination. If no path destination "
   "has yet been set, this returns \"0 0 0\"."

   "@see setPathDestination()\n")
{
	return object->getPathDestination();
}

void AIPlayer::followNavPath(Nav::NavPath *path)
{
   if(!isServerObject())
      return;

   // Get rid of our current path.
   clearPath();
   clearCover();
   clearFollow();

   // Follow new path.
   mPathData.path = path;
   mPathData.owned = false;
   // Start from 0 since we might not already be there.
   moveToNode(0);
}

DefineEngineMethod(AIPlayer, followNavPath, void, (SimObjectId obj),,
   "@brief Tell the AIPlayer to follow a path.\n\n"

   "@param obj ID of a NavPath object for the character to follow.")
{
   Nav::NavPath *path;
   if(Sim::findObject(obj, path))
      object->followNavPath(path);
}

void AIPlayer::followObject(SceneObject *obj, F32 radius)
{
   if(!isServerObject())
      return;

   if(setPathDestination(obj->getPosition()))
   {
      clearCover();
      mFollowData.object = obj;
      mFollowData.radius = radius;
   }
}

DefineEngineMethod(AIPlayer, followObject, void, (SimObjectId obj, F32 radius),,
   "@brief Tell the AIPlayer to follow another object.\n\n"

   "@param obj ID of the object to follow.\n"
   "@param radius Maximum distance we let the target escape to.")
{
   SceneObject *follow;
   if(Sim::findObject(obj, follow))
      object->followObject(follow, radius);
}

void AIPlayer::repath()
{
   // Ineffectual if we don't have a path, or are using someone else's.
   if(mPathData.path.isNull() || !mPathData.owned)
      return;

   // If we're following, get their position.
   if(!mFollowData.object.isNull())
      mPathData.path->mTo = mFollowData.object->getPosition();
   // Update from position and replan.
   mPathData.path->mFrom = getPosition();
   mPathData.path->plan();
   // Move to first node (skip start pos).
   moveToNode(1);
}

DefineEngineMethod(AIPlayer, repath, void, (),,
   "@brief Tells the AI to re-plan its path. Does nothing if the character "
   "has no path, or if it is following a mission path.\n\n")
{
   object->repath();
}

struct CoverSearch
{
   Point3F loc;
   Point3F from;
   F32 dist;
   F32 best;
   CoverPoint *point;
   CoverSearch() : loc(0, 0, 0), from(0, 0, 0)
   {
      best = -FLT_MAX;
      point = NULL;
      dist = FLT_MAX;
   }
};

static void findCoverCallback(SceneObject *obj, void *key)
{
   CoverPoint *p = dynamic_cast<CoverPoint*>(obj);
   if(!p || p->isOccupied())
      return;
   CoverSearch *s = static_cast<CoverSearch*>(key);
   Point3F dir = s->from - p->getPosition();
   dir.normalizeSafe();
   // Score first based on angle of cover point to enemy.
   F32 score = mDot(p->getNormal(), dir);
   // Score also based on distance from seeker.
   score -= (p->getPosition() - s->loc).len() / s->dist;
   // Finally, consider cover size.
   score += (p->getSize() + 1) / CoverPoint::NumSizes;
   score *= p->getQuality();
   if(score > s->best)
   {
      s->best = score;
      s->point = p;
   }
}

bool AIPlayer::findCover(const Point3F &from, F32 radius)
{
   if(radius <= 0)
      return false;

   // Create a search state.
   CoverSearch s;
   s.loc = getPosition();
   s.dist = radius;
   // Direction we seek cover FROM.
   s.from = from;

   // Find cover points.
   Box3F box(radius * 2.0f);
   box.setCenter(getPosition());
   getContainer()->findObjects(box, MarkerObjectType, findCoverCallback, &s);

   // Go to cover!
   if(s.point)
   {
      clearCover();
      clearFollow();
      mCoverData.cover = s.point;
      s.point->setOccupied(true);
      return setPathDestination(s.point->getPosition());
   }
   return false;
}

DefineEngineMethod(AIPlayer, findCover, bool, (Point3F from, F32 radius),,
   "@brief Tells the AI to find cover nearby.\n\n"

   "@param from   Location to find cover from (i.e., enemy position).\n"
   "@param radius Distance to search for cover.\n"
   "@return True if cover was found.\n\n")
{
   return object->findCover(from, radius);
}

Nav::NavMesh *AIPlayer::findNavMesh() const
{
   // Search for NavMeshes that contain us entirely with the smallest possible
   // volume.
   Nav::NavMesh *mesh = NULL;
   SimSet *set = Nav::NavMesh::getServerSet();
   for(U32 i = 0; i < set->size(); i++)
   {
      Nav::NavMesh *m = static_cast<Nav::NavMesh*>(set->at(i));
      if(m->getWorldBox().isContained(getWorldBox()))
      {
         // Check that mesh size is appropriate.
         if(mMount.object) // Should use isMounted() but it's not const. Grr.
         {
            if(!m->mVehicles)
               continue;
         }
         else
         {
            if(getNavSize() == Small && !m->mSmallCharacters ||
               getNavSize() == Regular && !m->mRegularCharacters ||
               getNavSize() == Large && !m->mLargeCharacters)
               continue;
         }
         if(!mesh || m->getWorldBox().getVolume() < mesh->getWorldBox().getVolume())
            mesh = m;
      }
   }
   return mesh;
}

DefineEngineMethod(AIPlayer, findNavMesh, S32, (),,
   "@brief Get the NavMesh object this AIPlayer is currently using.\n\n"

   "@return The ID of the NavPath object this character is using for "
   "pathfinding. This is determined by the character's location, "
   "navigation type and other factors. Returns -1 if no NavMesh is "
   "found.")
{
   Nav::NavMesh *mesh = object->getNavMesh();
   return mesh ? mesh->getId() : -1;
}

void AIPlayer::updateNavMesh()
{
   Nav::NavMesh *old = mNavMesh;
   if(mNavMesh.isNull())
      mNavMesh = findNavMesh();
   else
   {
      if(!mNavMesh->getWorldBox().isContained(getWorldBox()))
         mNavMesh = findNavMesh();
   }
   // See if we need to update our path.
   if(mNavMesh != old && !mPathData.path.isNull())
   {
      setPathDestination(mPathData.path->mTo);
   }
}

DefineEngineMethod(AIPlayer, getNavMesh, S32, (),,
   "@brief Return the NavMesh this AIPlayer is using to navigate.\n\n")
{
   Nav::NavMesh *m = object->getNavMesh();
   return m ? m->getId() : 0;
}

DefineEngineMethod(AIPlayer, setNavSize, void, (const char *size),,
   "@brief Set the size of NavMesh this character uses. One of \"Small\", \"Regular\" or \"Large\".")
{
   if(!dStrcmp(size, "Small"))
      object->setNavSize(AIPlayer::Small);
   else if(!dStrcmp(size, "Regular"))
      object->setNavSize(AIPlayer::Regular);
   else if(!dStrcmp(size, "Large"))
      object->setNavSize(AIPlayer::Large);
   else
      Con::errorf("AIPlayer::setNavSize: no such size '%s'.", size);
}

DefineEngineMethod(AIPlayer, getNavSize, const char*, (),,
   "@brief Return the size of NavMesh this character uses for pathfinding.")
{
   switch(object->getNavSize())
   {
   case AIPlayer::Small:
      return "Small";
   case AIPlayer::Regular:
      return "Regular";
   case AIPlayer::Large:
      return "Large";
   }
   return "";
}
</pre>

	<p>In <span class="path">engine directory/gfx/primBuilder.cpp</span>, replace this:</p>

<pre>
#ifdef TORQUE_DEBUG
U32 mMaxVerts;

#define INIT_VERTEX_SIZE(x) mMaxVerts = x;
#define VERTEX_BOUNDS_CHECK() AssertFatal( mCurVertIndex < mMaxVerts, "PrimBuilder encountered an out of bounds vertex! Break and debug!" );

// This next check shouldn't really be used a lot unless you are tracking down
// a specific bug. -pw
#define VERTEX_SIZE_CHECK() AssertFatal( mCurVertIndex <= mMaxVerts, "PrimBuilder allocated more verts than you used! Break and debug or rendering artifacts could occur." );

#else

#define INIT_VERTEX_SIZE(x)
#define VERTEX_BOUNDS_CHECK()
#define VERTEX_SIZE_CHECK()

#endif
</pre>

	<p>With:</p>

<pre>
U32 mMaxVerts;

static void CheckVertexBounds()
{
   // Grow vertex buffer
   if(mCurVertIndex == mMaxVerts)
   {
	  mMaxVerts *= 2;
	  mTempVertBuff.setSize(mMaxVerts);
   }
}

#ifdef TORQUE_DEBUG

#define INIT_VERTEX_SIZE(x) mMaxVerts = x;
//#define VERTEX_BOUNDS_CHECK() AssertFatal( mCurVertIndex < mMaxVerts, "PrimBuilder encountered an out of bounds vertex! Break and debug!" );
#define VERTEX_BOUNDS_CHECK() CheckVertexBounds()

// This next check shouldn't really be used a lot unless you are tracking down
// a specific bug. -pw
#define VERTEX_SIZE_CHECK() AssertFatal( mCurVertIndex <= mMaxVerts, "PrimBuilder allocated more verts than you used! Break and debug or rendering artifacts could occur." );

#else

#define INIT_VERTEX_SIZE(x) mMaxVerts = x;
#define VERTEX_BOUNDS_CHECK() CheckVertexBounds()
#define VERTEX_SIZE_CHECK()

#endif
</pre>

	<p class="title">4. REGENERATE SOLUTION</p>

	<p>Follow steps 3, 4 and 5 from the Easy install guide above.
	This will create a new Visual Studio solution for your project, so if you’ve made changes to it, you’ll need to redo them.
	Finally, follow step 6 (recompile the engine).
	You're good to go!</p>

	<h1 id="UAISK">UAISK integration</h1>

	<p><strong>Walkabout</strong> is a navigation solution, but chances are you want your characters to do more than go where you tell them without running into stuff!
	The <a href="http://www.garagegames.com/products/ai-starter-kit">Universal AI Starter Kit</a> is one of the premier addons providing AI for Torque 3D.
	This section will describe how to modify the UAISK to make full use of <strong>Walkabout</strong>'s navmeshes.</p>

	<p>First, we'll add some global variables that control how <strong>Walkabout</strong> behaves as part of the UAISK.
	In <span class="path">game/scripts/server/UAISK/aiGlobals.cs</span>, add the following to the bottom of the file:</p>

<pre>
//----------------------------------------------------------------
//The values below are Walkabout-specific

// Allow behaviors to make use of Walkabout navmeshes.
$AISK_WALKABOUT_ENABLE = true;

// Distance that characters should search for cover.
$AISK_WALKABOUT_COVER_RADIUS = 20;
</pre>

	<p>Next, let's make moving AI units actually use our new pathfinding!
	The UAISK routes most of its movement through the AIPlayer::movementPositionFilter function.
	We're going to hijack part of this function to use <strong>Walkabout</strong> instead of the standard movement algorithm.
	In <span class="path">game/scripts/server/UAISK/aiMovement.cs</span>, replace this block:</p>

<pre>
    //Do a simple test to see if the bot can go directly to its target destination,
    //or if it needs to do something fancy to go around an obstacle
    if (%this.checkMovementLos(%obj, %eyeTrans, %this.moveDestinationB) == 0)
        %obj.setmovedestination(%this.moveDestinationB);
</pre>

	<p>With:</p>

<pre>
    if($AISK_WALKABOUT_ENABLE && %this.behavior.useWalkabout && isObject(%this.getNavMesh()))
        // Use Walkabout pathfinding.
        %this.setPathDestination(%this.moveDestinationB);
    //Do a simple test to see if the bot can go directly to its target destination,
    //or if it needs to do something fancy to go around an obstacle
    else if (%this.checkMovementLos(%obj, %eyeTrans, %this.moveDestinationB) == 0)
        %obj.setmovedestination(%this.moveDestinationB);
</pre>

	<p>Notice that you can specify which behaviours use <strong>Walkabout</strong> by setting the useWalkabout property.</p>

	<p>Now, we'll add a bit of spice: allowing AIPlayers that have been damaged to take cover.
	The Armor::damage function is called when AIPlayers are damaged.
	Currently, the UAISK uses this callback to do things like maki aggressive AIs respond to being shot at.
	In <span class="path">game/scripts/server/player.cs</span>, replace the following block:</p>

<pre>
        //Move a little when hit, aggressive bots move in the "Defending" state
        if (!%obj.behavior.isAggressive)
            %obj.sidestep(%obj, true);
</pre>

	<p>With:</p>

<pre>
        //Move a little when hit, aggressive bots move in the "Defending" state
        if (!%obj.behavior.isAggressive)
        {
            if($AISK_WALKABOUT_ENABLE && %this.behavior.useWalkabout && %this.behavior.useCover && isObject(%this.getNavMesh()))
            {
                // Try to take cover. If that fails, just sidestep!
                if(!%this.findCover(%sourceObject.getPosition(), $AISK_WALKABOUT_COVER_RADIUS))
                    %this.sidestep(%this, true);
            }
            else
                %obj.sidestep(%obj, true);
        }
</pre>

	<p>Next, we'll modify bots' pathed movement.
	We're going to make bots find a <strong>Walkabout</strong> path between each UAISK path node they travel through.
	This will allow you to use paths as 'waypoints', instead of having to place a path node at every corner.
	For example, you could put one path node inside a building, the next up a hill, and the final one on a bridge, and bots will find proper paths between these points.
	If your level geometry changes or you decide to move your path nodes around, the bots will still find correct paths!</p>

	<p>In <span class="path">game/scripts/server/UAISK/aiPathed.cs</span>, replace this:</p>

<pre>
    //The 0 at the end sets if the bot should slow down or not, you can change it if needed
    %obj.setMoveDestination(%node.getPosition(), 0);
</pre>

	<p>With:</p>

<pre>
    if($AISK_WALKABOUT_ENABLE && %this.behavior.useWalkabout && isObject(%this.getNavMesh()))
        %this.setPathDestination(%node.getPosition());
    else
        //The 0 at the end sets if the bot should slow down or not, you can change it if needed
        %obj.setMoveDestination(%node.getPosition(), 0);
</pre>

	<p>Finally, we need to set the useWalkabout and useCover properties on behaviours that you want to use pathfinding.
	The behaviours are in <span class="path">game/scripts/server/UAISK/aiBehavoirs.cs</span>.
	I recommend setting useWalkabout to true for the Chase behaviour, and useWalkabout and useCover to true for the KillableNPC behaviour.</p>
	<p>All done! Now, if you start up your game using the UAISK, you should see your characters using navmeshes and taking cover.</p>

</body>
</html>
