<!DOCTYPE html>

<html>
<head>
	<title>Installation Guide| Walkabout</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
	<img src="images/walkabout.png" class="banner" />
	<p class="title">INSTALLATION GUIDE</p>

	<ol class="toc">
		<li><a href="#introduction">Introduction</a></li>
		<li><a href="#structure">Directory structure</a></li>
		<li><a href="#easy">Easy install (new project)</a></li>
		<li><a href="#winmerge">Installing with WinMerge (existing project)</a></li>
		<li><a href="#custom">Custom install (existing project)</a></li>
		<li><a href="#UAISK">UAISK integration</a></li>
	</ol>

	<h1 id="introduction">Introduction</h1>
	<p>This guide will walk you through the process of installing <strong>Walkabout</strong> into Torque 3D.
	<strong>Walkabout</strong> is a complex product and requires significant additions (and a few modifications) to the engine code.
	If you follow this guide, you should be fine, but if you need more detailed information on the modifications <strong>Walkabout</strong> makes, see the Engine Modifications file.</p>

	<p>If you’re installing <strong>Walkabout</strong> into a new project that you haven’t started to modify already, you’re in luck: your install should be very simple.
	Follow the guide in the <a href="#easy">Easy install</a> section below.</p>

	<p>If you’ve made source code or script changes already, however, you have two options.
	The difficult option is to follow the instructions in the <a href="#custom">Custom install</a> section.
	The easy option is to install a program like <a href="#winmerge">WinMerge</a>, which will let you visually merge the differences between your code and <strong>Walkabout</strong>’s code.</p>

	<p class="important"><strong>IMPORTANT!</strong>
	It is highly recommended that you do not perform a full manual install.
	The instructions are included for completeness, but starting from a fresh project or using WinMerge are much easier!</p>

	<h1 id="structure">Directory structure</h1>
	<p>In the instructions below, I want to make as few assumptions as I can about where you’ve installed Torque and how your projects are laid out.
	With that in mind, here are some abbreviations I will use:</p>

	<table>
		<tr><th>Abbreviation</th> <th>Explanation</th> <th>Example</th></tr>
		<tr><td>install directory</td> <td>The location you installed Torque 3D.</td> <td class="path">C:\Torque\Torque 3D 1.1 Final</td></tr>
		<tr><td>engine directory</td> <td>The location of Torque’s engine source files.</td> <td class="path">C:\Torque\Torque 3D 1.1 Final\Engine\source</td></tr>
		<tr><td>project directory</td> <td>The location of the project you’d like to install <strong>Walkabout</strong> to.</td> <td class="path">C:\Torque\Torque 3D 1.1 Final\My Projects\SuperFunGame</td></tr>
		<tr><td>game directory</td> <td>The location of your project’s game folder.</td> <td class="path">C:\Torque\Torque 3D 1.1 Final\My Projects\SuperFunGame\game</td></tr>
		<tr><td>Walkabout</td> <td>The folder that contains your <strong>Walkabout</strong> download.</td> <td class="path">C:\Users\Me\Downloads\Walkabout R1\Torque 3D 1.1 Final</td></tr>
	</table>

	<h1 id="easy">Easy install (new project)</h1>
	<p>If you’re working with a new T3D install (blank project based on Full or Empty template),
	then you will be able to simply copy over all the files in your <strong>Walkabout</strong> download and overwrite the existing ones.
	To install <strong>Walkabout</strong> in a new T3D project, do the following:</p>
	<ol>
		<li>Copy <span class="path">Walkabout/Engine/source</span> to <span class="path">engine directory</span> and select ‘Copy and Replace’ for all items when prompted.</li>
		<li>Copy <span class="path">Walkabout/game</span> to <span class="path">game directory</span> and select ‘Copy and Replace’ for all items when prompted.</li>
		<li>In <span class="path">install directory/Tools/projectGeneraor/modules</span>, open <span class="path">T3D.inc</span> with a regular text editor
		(Notepad, Notepad++, and WordPad should be fine. Do not use Microsoft Word, OpenOffice, or other word processors!).<br />
		After this line:<br />
		<pre>addEngineSrcDir('environment');</pre>
		Add this: <br />
		<pre>addEngineSrcDir('walkabout');</pre></li>
		<li>In project directory, double-click on <span class="path">generateProjects.bat</span>.</li>
		<li>Recompile the engine.</li>
	</ol>

	<h1 id="winmerge">Installing with WinMerge (existing project)</h1>
	<p>If you have already made script and source code changes to Torque 3D in your own project,
	you’ll need to be a bit more careful when you integrate <strong>Walkabout</strong>, to avoid its changes overwriting your own changes!</p>

	<p>Once you’ve installed <a href="http://www.winmerge.org">WinMerge</a> or the merging tool of your choice, follow the steps below.
	Note that instructions will assume you are using WinMerge - if your merge tool has differences, you’ll need to work them out yourself!</p>

	<p>First, compare <span class="path">Walkabout/source</span> to <span class="path">engine directory</span>.
	If there is a file with differences, double-click it to view and edit them.</p>

	<img src="images/winmerge-dir.png" />
	<p class="caption">Viewing differences in the T3D directory.</p>

	<p>Once inside a file, press Alt+Down to quickly scroll to the next difference,
	and Alt+Right to copy from the left-hand-side (<strong>Walkabout</strong> file) to the right-hand-side (your engine file).</p>

	<img src="images/winmerge-file.png" />
	<p class="caption">Editing conflicts inside a file.</p>

	<p>Next, compare <span class="path">Walkabout/game</span> to <span class="path">game directory</span>. Copy over files that don’t exist in your tree, and edit any conflicts within existing files.</p>

	<p>Finally, follow steps 3-5 from <a href="#easy">Easy install</a>.
	Note that step 4 will rewrite your Visual Studio project files, so if you’ve modified them, you will need to redo those modifications.</p>

	<h1 id="custom">Custom install (existing project)</h1>

	<p class="title">1. COPY NEW FILES</p>

	<ol>
		<li>Copy <span class="path">Walkabout/source/walkabout</span> to <span class="path">engine directory</span></li>
		<li>Copy <span class="path">Walkabout/source/collision/objPolyList.*</span> to <span class="path">engine directory/collision</span></li>
		<li>Copy <span class="path">Walkabout/game/tools</span> to <span class="path">game directory</span></li>
		<li>Optionally, copy <span class="path">Walkabout/game/scripts/server/walkabout* to <span class="path">game directory/server/scripts</span></li>
	</ol>

	<p class="title">2. SOURCE CODE MODIFICATIONS</p>

	<p>In engine directory/scene/sceneContainer.h, after:</p>

<pre>
   /// A hint that the polyist is used for
   /// selection from an editor or other tool.
   PLC_Selection,
</pre>

	<p>Add:</p>

<pre>
   /// A hint that the polylist is used for
   /// building a representation of the environment
   /// used for navigation.
   PLC_Navigation,
</pre>

	<p>In engine directory/T3D/convexShape.cpp, after:</p>

<pre>
   // Add Surfaces...

  const Vector< ConvexShape::Face > faceList = mGeometry.faces;
</pre>

	<p>Add:</p>

<pre>
   if(context == PLC_Navigation)
   {
	  for(S32 i = 0; i < faceList.size(); i++)
	  {
		 const ConvexShape::Face &face = faceList[i];                

		 S32 s = face.triangles.size();
		 for(S32 j = 0; j < s; j++)
		 {
			plist->begin(0, s*i + j);

			plist->plane(PlaneF(face.centroid, face.normal));

			plist->vertex(base + face.points[face.triangles[j].p0]);
			plist->vertex(base + face.points[face.triangles[j].p1]);
			plist->vertex(base + face.points[face.triangles[j].p2]);

			plist->end();
		 }      
	  }
	  return true;
   }
</pre>


	<p>In engine directory/T3D/groundPlane.cpp, replace this method:</p>
<pre>
bool GroundPlane::buildPolyList( PolyListContext context, AbstractPolyList* polyList, const Box3F&, const SphereF& )
{
   ...
}
</pre>

	<p>With:</p>

<pre>
bool GroundPlane::buildPolyList( PolyListContext context, AbstractPolyList* polyList, const Box3F& box, const SphereF& )
{
   polyList->setObject( this );
   polyList->setTransform( &MatrixF::Identity, Point3F( 1.0f, 1.0f, 1.0f ) );

   if(context == PLC_Navigation)
   {
	  F32 z = getPosition().z;
	  Point3F
		 p0(box.minExtents.x, box.maxExtents.y, z),
		 p1(box.maxExtents.x, box.maxExtents.y, z),
		 p2(box.maxExtents.x, box.minExtents.y, z),
		 p3(box.minExtents.x, box.minExtents.y, z);

	  // Add vertices to poly list.
	  U32 v0 = polyList->addPoint(p0);
	  polyList->addPoint(p1);
	  polyList->addPoint(p2);
	  polyList->addPoint(p3);

	  // Add plane between first three vertices.
	  polyList->begin(0, 0);
	  polyList->vertex(v0);
	  polyList->vertex(v0+1);
	  polyList->vertex(v0+2);
	  polyList->plane(v0, v0+1, v0+2);
	  polyList->end();

	  // Add plane between last three vertices.
	  polyList->begin(0, 1);
	  polyList->vertex(v0+2);
	  polyList->vertex(v0+3);
	  polyList->vertex(v0);
	  polyList->plane(v0+2, v0+3, v0);
	  polyList->end();

	  return true;
   }

   Box3F planeBox = getPlaneBox();
   polyList->addBox( planeBox, mMaterial );

   return true;
}
</pre>

	<p>In engine directory/terrain/terrCollision.cpp, replace this line:</p>

<pre>
bool TerrainBlock::buildPolyList(PolyListContext, AbstractPolyList* polyList, const Box3F &box, const SphereF&)
</pre>

	<p>With:</p>

<pre>
bool TerrainBlock::buildPolyList(PolyListContext context, AbstractPolyList* polyList, const Box3F &box, const SphereF&)
</pre>

	<p>Replace this block:</p>

<pre>
  //
  for (S32 x = xStart; x < xEnd; x++) 
  {
	 S32 xi = x & BlockMask;
	 const TerrainSquare *sq = mFile->findSquare( 0, xi, yi );
</pre>

	<p>With:</p>

<pre>
	  F32 wy1 = y * mSquareSize, wy2 = (y + 1) * mSquareSize;
	  if(((wy1 > osBox.maxExtents.y && wy2 > osBox.maxExtents.y) ||
		  (wy1 < osBox.minExtents.y && wy2 < osBox.minExtents.y)) &&
		   context == PLC_Navigation)
		 continue;

	  //
	  for (S32 x = xStart; x < xEnd; x++) 
	  {
		 S32 xi = x & BlockMask;
		 const TerrainSquare *sq = mFile->findSquare( 0, xi, yi );

		 F32 wx1 = x * mSquareSize, wx2 = (x + 1) * mSquareSize;
		 if(((wx1 > osBox.maxExtents.x && wx2 > osBox.maxExtents.x) ||
			 (wx1 < osBox.minExtents.x && wx2 < osBox.minExtents.x)) &&
			  context == PLC_Navigation)
			continue;
</pre>

	<p>In engine directory/T3D/aiPlayer.h, after:</p>

<pre>
#ifndef _PLAYER_H_
#include "T3D/player.h"
#endif
</pre>

	<p>Add:</p>

<pre>
#include "nav/navPath.h"
#include "nav/navMesh.h"
#include "nav/coverPoint.h"
</pre>

	<p>After:</p>

<pre>
   // Utility Methods
   void throwCallback( const char *name );
</pre>

	<p>Add:</p>

<pre>
   /// Should we jump next time we leave the ground?
   bool mJump;

   /// Stores information about a path.
   struct PathData {
	  /// Pointer to path object.
	  SimObjectPtr<Nav::NavPath> path;
	  /// Do we own our path? If so, we will delete it when finished.
	  bool owned;
	  /// Path node we're at.
	  U32 index;
	  /// Default constructor.
	  PathData() : path(NULL)
	  {
		 owned = false;
		 index = 0;
	  }
   };

   /// Path we are currently following.
   PathData mPathData;

   /// Clear out the current path.
   void clearPath();

   /// Stores information about our cover.
   struct CoverData {
	  /// Pointer to a cover point.
	  SimObjectPtr<CoverPoint> cover;
	  /// Default constructor.
	  CoverData() : cover(NULL)
	  {
	  }
   };

   /// Current cover we're trying to get to.
   CoverData mCoverData;

   /// Stop searching for cover.
   void clearCover();

   /// NavMesh we pathfind on.
   SimObjectPtr<Nav::NavMesh> mNavMesh;

   /// Move to the specified node in the current path.
   void moveToNode(S32 node);

protected:
   virtual void onReachDestination();
   virtual void onStuck();
</pre>

	<p>After:</p>

<pre>
   void stopMove();
</pre>

	<p>Add:</p>

<pre>
   /// @name Pathfinding
   /// @{

   enum NavSize {
	  Small,
	  Regular,
	  Large
   } mNavSize;
   void setNavSize(NavSize size) { mNavSize = size; updateNavMesh(); }
   NavSize getNavSize() const { return mNavSize; }

   void setPathDestination(const Point3F &pos);
   Point3F getPathDestination() const;

   void followNavPath(Nav::NavPath *path);
   void followObject(SceneObject *obj);

   void repath();

   void findCover(const Point3F &from, F32 radius);

   Nav::NavMesh *findNavMesh() const;
   void updateNavMesh();
   Nav::NavMesh *getNavMesh() const { return mNavMesh; }

   /// @}
</pre>

	<p>In engine directory.T3D/aiPlayer.cpp, after:</p>

<pre>
   mAimOffset = Point3F(0.0f, 0.0f, 0.0f);
</pre>

	<p>Add:</p>

<pre>
   mJump = false;
   mNavSize = Regular;
</pre>

	<p>After:</p>

<pre>
   Point3F location = eye.getPosition();
   Point3F rotation = getRotation();
</pre>

	<p>Add:</p>

<pre>
   updateNavMesh();
</pre>

	<p>Replace this:</p>

<pre>
		 mMoveState = ModeStop;
		 throwCallback("onReachDestination");
</pre>

	<p>With:</p>

<pre>
		 mMoveState = ModeStop;
		 onReachDestination();
</pre>

	<p>Replace this:</p>

<pre>
			   mMoveState = ModeStuck;
			   throwCallback("onMoveStuck");
</pre>

	<p>With:</p>

<pre>
			   mMoveState = ModeStuck;
			   onStuck();
</pre>

	<p>After:</p>

<pre>
   for( int i = 0; i < MaxTriggerKeys; i++ )
	  movePtr->trigger[i] = getImageTriggerState(i);
</pre>

	<p>Add:</p>

<pre>
   if(mJump)
   {
	  // If we're not touching the ground, jump!
	  RayInfo info;
	  if(!getContainer()->castRay(getPosition(), getPosition() - Point3F(0, 0, 0.4f), StaticShapeObjectType, &info))
	  {
		 movePtr->trigger[2] = true;
		 mJump = false;
	  }
   }
</pre>

	<p>After:</p>

<pre>
void AIPlayer::throwCallback( const char *name )
{
   Con::executef(getDataBlock(), name, getIdString());
}
</pre>

	<p>Add:</p>

<pre>
/**
 * Called when we get within mMoveTolerance of our destination set using
 * setMoveDestination(). Only fires the script callback if we are at the end
 * of a pathfinding path, or have no pathfinding path.
 */
void AIPlayer::onReachDestination()
{
   if(!mPathData.path.isNull())
   {
	  if(mPathData.index == mPathData.path->size() - 1)
	  {
		 // Handle looping paths.
		 if(mPathData.path->mIsLooping)
			moveToNode(0);
		 // Otherwise end path.
		 else
		 {
			clearPath();
			throwCallback("onReachDestination");
		 }
	  }
	  else
		 moveToNode(mPathData.index + 1);
   }
   else
	  throwCallback("onReachDestination");
}

/**
 * Called when we move less than mMoveStuckTolerance in a tick, signalling
 * that some obstacle is preventing us from getting where we need to go.
 */
void AIPlayer::onStuck()
{
   if(!mPathData.path.isNull())
	  repath();
   else
	  throwCallback("onMoveStuck");
}

// --------------------------------------------------------------------------------------------
// Pathfinding
// --------------------------------------------------------------------------------------------

void AIPlayer::clearPath()
{
   // Only delete if we own the path.
   if(!mPathData.path.isNull() && mPathData.owned)
	  mPathData.path->deleteObject();
   // Reset path data.
   mPathData = PathData();
   // Stop moving.
   stopMove();
}

void AIPlayer::clearCover()
{
   // Notify cover that we are no longer on our way.
   if(!mCoverData.cover.isNull())
	  mCoverData.cover->setOccupied(false);
   mCoverData = CoverData();
}

void AIPlayer::moveToNode(S32 node)
{
   if(mPathData.path.isNull())
	  return;

   // -1 is shorthand for 'last path node'.
   if(node == -1)
	  node = mPathData.path->size() - 1;

   // Consider slowing down on the last path node.
   setMoveDestination(mPathData.path->getNode(node), false);

   // Check flags for this segment.
   if(mPathData.index)
   {
	  U8 flags = mPathData.path->getFlags(node - 1);
	  if(flags & Nav::JumpFlag)
		 // Jump if we must.
		 mJump = true;
	  else
		 // Catch pathing errors.
		 mJump = false;
   }

   // Store current index.
   mPathData.index = node;
}

void AIPlayer::setPathDestination(const Point3F &pos)
{
   // Pathfinding only happens on the server.
   if(!isServerObject())
	  return;

   if(!getNavMesh())
	  updateNavMesh();
   // If we can't find a mesh, just move regularly.
   //if(!getNavMesh())
   //{
   //   setMoveDestination(pos);
   //   return;
   //}

   // Create a new path.
   Nav::NavPath *path = new Nav::NavPath();
   if(path)
   {
	  path->mMesh = getNavMesh();
	  path->mFrom = getPosition();
	  path->mTo = pos;
	  path->mFromSet = path->mToSet = true;
	  path->mAlwaysRender = true;
	  // Paths plan automatically upon being registered.
	  if(!path->registerObject())
	  {
		 delete path;
		 return;
	  }
   }
   else
	  return;

   if(path->success())
   {
	  // Clear any current path we might have.
	  clearPath();
	  clearCover();
	  // Store new path.
	  mPathData.path = path;
	  mPathData.owned = true;
	  // Skip node 0, which we are currently standing on.
	  moveToNode(1);
   }
   else
   {
	  // Just move normally if we can't path.
	  //setMoveDestination(pos, true);
	  //return;
	  path->deleteObject();
   }
}

DefineEngineMethod(AIPlayer, setPathDestination, void, (Point3F goal),,
   "@brief Tells the AI to find a path to the location provided\n\n"

   "@param goal Coordinates in world space representing location to move to.\n\n"

   "@see getPathDestination()\n"
   "@see setMoveDestination()\n")
{
   object->setPathDestination(goal);
}

Point3F AIPlayer::getPathDestination() const
{
   if(!mPathData.path.isNull())
	  return mPathData.path->mTo;
   return Point3F(0, 0, 0);
}

DefineEngineMethod(AIPlayer, getPathDestination, Point3F, (),,
   "@brief Get the AIPlayer's current pathfinding destination.\n\n"


   "@return Returns a point containing the \"x y z\" position "
   "of the AIPlayer's current path destination. If no path destination "
   "has yet been set, this returns \"0 0 0\"."

   "@see setPathDestination()\n")
{
		return object->getPathDestination();
}

void AIPlayer::followNavPath(Nav::NavPath *path)
{
   if(!isServerObject())
	  return;

   // Get rid of our current path.
   clearPath();
   clearCover();

   // Follow new path.
   mPathData.path = path;
   mPathData.owned = false;
   // Start from 0 since we might not already be there.
   moveToNode(0);
}

DefineEngineMethod(AIPlayer, followNavPath, void, (SimObjectId obj),,
   "@brief Tell the AIPlayer to follow a path.\n\n"

   "@param obj ID of a NavPath object for the character to follow.")
{
   Nav::NavPath *path;
   if(Sim::findObject(obj, path))
	  object->followNavPath(path);
}

void AIPlayer::followObject(SceneObject *obj)
{
}

void AIPlayer::repath()
{
   // Ineffectual if we don't have a path, or are using someone else's.
   if(mPathData.path.isNull() || !mPathData.owned)
	  return;

   // Update from position and replan.
   mPathData.path->mFrom = getPosition();
   mPathData.path->plan();
   // Move to first node (skip start pos).
   moveToNode(1);
}

DefineEngineMethod(AIPlayer, repath, void, (),,
   "@brief Tells the AI to re-plan its path. Does nothing if the character "
   "has no path, or if it is following a mission path.\n\n")
{
   object->repath();
}

struct CoverSearch
{
   Point3F loc;
   Point3F from;
   F32 dist;
   F32 best;
   CoverPoint *point;
   CoverSearch() : loc(0, 0, 0), from(0, 0, 0)
   {
	  best = -FLT_MAX;
	  point = NULL;
	  dist = FLT_MAX;
   }
};

static void findCoverCallback(SceneObject *obj, void *key)
{
   CoverPoint *p = dynamic_cast<CoverPoint*>(obj);
   if(!p || p->isOccupied())
	  return;
   CoverSearch *s = static_cast<CoverSearch*>(key);
   Point3F dir = s->from - p->getPosition();
   dir.normalizeSafe();
   // Score first based on angle of cover point to enemy.
   F32 score = mDot(p->getNormal(), dir);
   // Score also based on distance from seeker.
   score -= (p->getPosition() - s->loc).len() / s->dist;
   // Finally, consider cover size.
   score += (p->getSize() + 1) / CoverPoint::NumSizes;
   score *= p->getQuality();
   if(score > s->best)
   {
	  s->best = score;
	  s->point = p;
   }
}

void AIPlayer::findCover(const Point3F &from, F32 radius)
{
   if(radius <= 0)
	  return;

   // Create a search state.
   CoverSearch s;
   s.loc = getPosition();
   s.dist = radius;
   // Direction we seek cover FROM.
   s.from = from;

   // Find cover points.
   Box3F box(radius * 2.0f);
   box.setCenter(getPosition());
   getContainer()->findObjects(box, MarkerObjectType, findCoverCallback, &s);

   // Go to cover!
   if(s.point)
   {
	  setPathDestination(s.point->getPosition());
	  clearCover();
	  mCoverData.cover = s.point;
	  s.point->setOccupied(true);
   }
}

DefineEngineMethod(AIPlayer, findCover, void, (Point3F from, F32 radius),,
   "@brief Tells the AI to find cover nearby.\n\n"

   "@param from   Location to find cover from (i.e., enemy position).\n"
   "@param radius Distance to search for cover.\n\n")
{
   object->findCover(from, radius);
}

Nav::NavMesh *AIPlayer::findNavMesh() const
{
   // Search for NavMeshes that contain us entirely with the smallest possible
   // volume.
   Nav::NavMesh *mesh = NULL;
   SimSet *set = Nav::NavMesh::getServerSet();
   for(U32 i = 0; i < set->size(); i++)
   {
	  Nav::NavMesh *m = static_cast<Nav::NavMesh*>(set->at(i));
	  if(m->getWorldBox().isContained(getWorldBox()))
	  {
		 // Check that mesh size is appropriate.
		 if(mMount.object) // Should use isMounted() but it's not const. Grr.
		 {
			if(!m->mVehicles)
			   continue;
		 }
		 else
		 {
			if(getNavSize() == Small && !m->mSmallCharacters ||
			   getNavSize() == Regular && !m->mRegularCharacters ||
			   getNavSize() == Large && !m->mLargeCharacters)
			   continue;
		 }
		 if(!mesh || m->getWorldBox().getVolume() < mesh->getWorldBox().getVolume())
			mesh = m;
	  }
   }
   return mesh;
}

DefineEngineMethod(AIPlayer, findNavMesh, S32, (),,
   "@brief Get the NavMesh object this AIPlayer is currently using.\n\n"

   "@return The ID of the NavPath object this character is using for "
   "pathfinding. This is determined by the character's location, "
   "navigation type and other factors. Returns -1 if no NavMesh is "
   "found.")
{
   Nav::NavMesh *mesh = object->getNavMesh();
   return mesh ? mesh->getId() : -1;
}

void AIPlayer::updateNavMesh()
{
   Nav::NavMesh *old = mNavMesh;
   if(mNavMesh.isNull())
	  mNavMesh = findNavMesh();
   else
   {
	  if(!mNavMesh->getWorldBox().isContained(getWorldBox()))
		 mNavMesh = findNavMesh();
   }
   // See if we need to update our path.
   if(mNavMesh != old && !mPathData.path.isNull())
   {
	  setPathDestination(mPathData.path->mTo);
   }
}

DefineEngineMethod(AIPlayer, getNavMesh, S32, (),,
   "@brief Return the NavMesh this AIPlayer is using to navigate.\n\n")
{
   Nav::NavMesh *m = object->getNavMesh();
   return m ? m->getId() : 0;
}

DefineEngineMethod(AIPlayer, setNavSize, void, (const char *size),,
   "@brief Set the size of NavMesh this character uses. One of \"Small\", \"Regular\" or \"Large\".")
{
   if(!dStrcmp(size, "Small"))
	  object->setNavSize(AIPlayer::Small);
   else if(!dStrcmp(size, "Regular"))
	  object->setNavSize(AIPlayer::Regular);
   else if(!dStrcmp(size, "Large"))
	  object->setNavSize(AIPlayer::Large);
   else
	  Con::errorf("AIPlayer::setNavSize: no such size '%s'.", size);
}

DefineEngineMethod(AIPlayer, getNavSize, const char*, (),,
   "@brief Return the size of NavMesh this character uses for pathfinding.")
{
   switch(object->getNavSize())
   {
   case AIPlayer::Small:
	  return "Small";
   case AIPlayer::Regular:
	  return "Regular";
   case AIPlayer::Large:
	  return "Large";
   }
   return "";
}
</pre>

	<p>In engine directory/gfx/primBuilder.cpp, replace this:</p>

<pre>
#ifdef TORQUE_DEBUG
U32 mMaxVerts;

#define INIT_VERTEX_SIZE(x) mMaxVerts = x;
#define VERTEX_BOUNDS_CHECK() AssertFatal( mCurVertIndex < mMaxVerts, "PrimBuilder encountered an out of bounds vertex! Break and debug!" );

// This next check shouldn't really be used a lot unless you are tracking down
// a specific bug. -pw
#define VERTEX_SIZE_CHECK() AssertFatal( mCurVertIndex <= mMaxVerts, "PrimBuilder allocated more verts than you used! Break and debug or rendering artifacts could occur." );

#else

#define INIT_VERTEX_SIZE(x)
#define VERTEX_BOUNDS_CHECK()
#define VERTEX_SIZE_CHECK()

#endif
</pre>

	<p>With:</p>

<pre>
U32 mMaxVerts;

static void CheckVertexBounds()
{
   // Grow vertex buffer
   if(mCurVertIndex == mMaxVerts)
   {
	  mMaxVerts *= 2;
	  mTempVertBuff.setSize(mMaxVerts);
   }
}

#ifdef TORQUE_DEBUG

#define INIT_VERTEX_SIZE(x) mMaxVerts = x;
//#define VERTEX_BOUNDS_CHECK() AssertFatal( mCurVertIndex < mMaxVerts, "PrimBuilder encountered an out of bounds vertex! Break and debug!" );
#define VERTEX_BOUNDS_CHECK() CheckVertexBounds()

// This next check shouldn't really be used a lot unless you are tracking down
// a specific bug. -pw
#define VERTEX_SIZE_CHECK() AssertFatal( mCurVertIndex <= mMaxVerts, "PrimBuilder allocated more verts than you used! Break and debug or rendering artifacts could occur." );

#else

#define INIT_VERTEX_SIZE(x) mMaxVerts = x;
#define VERTEX_BOUNDS_CHECK() CheckVertexBounds()
#define VERTEX_SIZE_CHECK()

#endif
</pre>

	<p class="title">4. REGENERATE SOLUTION</p>

	<p>Follow steps 3, 4 and 5 from the Easy install guide above.
	This will create a new Visual Studio solution for your project, so if you’ve made changes to it, you’ll need to redo them.</p>

	<h1 id="UAISK">UAISK integration</h1>
</body>
</html>
